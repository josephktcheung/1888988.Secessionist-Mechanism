# 归并国机制热修模组 - 白皮书摘要

**目的：** 本文档总结了基于模组的归并国机制问题解决方案的根本局限性，以及为什么最终需要引擎修复。

**目标受众：** 考虑基于模组解决方案的模组制作者、游戏设计师和开发者。

---

## ⚠️ 关键局限性：被动应对，而非主动预防（标准方法）

**根本问题：** 标准模组方法无法实现防止不应发生的战争的理想目标。

### 模组无法做到的事情（标准被动方法）

一旦归并国战争被宣布，硬编码的引擎逻辑会立即触发，许多效果是**不可逆的**：

1. **硬编码引擎逻辑首先触发：** 引擎的 `on_civil_war_start` 逻辑在模组能够干预**之前**就调用文化主导国家
2. **立即惩罚：** 当有停战协议的国家被强制参战时，违反停战协议的惩罚（-50 稳定度，+1 厌战度，+25 敌意）会立即应用
3. **联合统治破裂：** 带有 `break_on_war = yes` 的联合统治可能会立即破裂，模组无法阻止
4. **国家已参战：** 当模组能够响应时（即使只有 1 天延迟），国家已经是参战方
5. **损害已造成：** 战争已经开始，国家已被召唤，惩罚已应用，关系可能已破裂

### 模组可以做到的事情（有限缓解 - 标准方法）

标准模组方法只能**事后**缓解损害：

- 允许国家立即退出（但无法撤销已应用的惩罚）
- 移除白和产生的不必要停战协议
- 通过战争目标验证防止"吞并叛军"漏洞
- 允许玩家通过游戏规则控制参与（但只能在进入后）

**现实（标准方法）：** 当 `on_civil_war_start` 触发且模组能够响应时，战争已经开始，国家已被召唤，惩罚已应用。标准模组从根本上是一个**损害缓解工具**，而非预防机制。

**结论：** 理想解决方案 - 防止不当战争开始 - 需要引擎修复或下面描述的替代预防方法。

---

## 替代方法：模拟独立然后宣战（理论性）

**概念：** 通过模拟叛军首先赢得独立，然后创建具有正确领导层的新战争，完全绕过当前的归并国机制。

### 关键设计原则

1. **仅适用于归并国内战（非民族主义独立战争）**
   - 归并国叛军基于文化并触发 `on_civil_war_start`
   - 民族主义叛军（来自核心）创建常规战争，不触发归并国机制
   - **原因：** 民族主义独立战争不需要此修复 - 它们已经是具有正确行为的常规战争

2. **假设保护者存在**
   - 如果不存在文化主导国家，归并国机制无论如何都不会触发
   - 叛军将作为常规民族主义独立战争单独战斗（这没问题）
   - **重点：** 仅处理存在保护者且需要正确战争领导层的情况

3. **保护者选择优先级系统**
   - **顺序：** 原持有者 > 邻近同文化国家 > 文化主导国家
   - **原因：** 尊重历史主张并防止远距离国家被召唤

### 实施方法

**为什么我们无法重用原始归并国国家创建代码：**
- 国家创建逻辑**硬编码在引擎中**（C++ 代码，不在任何可模组化的游戏文件中）
- `on_civil_war_start` 在国家已经创建**之后**触发
- 当叛军进度达到 100% 时，我们**无法阻止 `start_civil_war` 触发** - 没有 `on_rebel_progress` 或 `on_rebel_breakout` on_action 可以拦截
- 引擎逻辑**不可模组化** - 我们只能事后响应

**推荐方法：自己创建国家（在 `start_civil_war` 触发之前）**

**拦截时机选项：**
- **选项 A：在 99% 进度时拦截**（通过月度事件检查 `rebel_progress >= 0.99` 且 `rebel_last_months_progress >= 0.01`）
  - **最安全的方法** - 保证我们在 100% 之前捕获
  - 在创建国家之前需要验证（验证叛军仍然存在且条件仍然满足）
- **选项 B：在 100% 进度时拦截**（通过月度事件检查 `rebel_progress >= 1.0`）
  - **时机不确定** - 取决于执行顺序（需要测试）
  - 如果月度事件在 `start_civil_war` **之前**触发：✅ 可以拦截
  - 如果 `start_civil_war` 立即触发：❌ 无法拦截（已触发当前机制）

**实施步骤：**
1. 创建由 `monthly_country_pulse` on_action 触发的月度事件
2. 检查满足拦截条件的归并国叛军（见上面的时机选项）
3. **关键验证：** 在创建国家之前，验证：
   - 叛军仍然存在（未被玩家行动摧毁）
   - `rebel_progress >= 0.99`（仍然处于高进度）
   - `rebel_last_months_progress > 0`（未被压制）
   - 如果验证失败，中止（玩家干预）
4. 识别叛军控制的所有具有反叛文化的位置（使用 `dominant_culture` 或人口忠诚度）
5. 创建国家标签（动态生成或基于文化）
6. 为这些基于文化的位置添加新国家标签的核心
7. 使用 `create_country_from_cores_in_our_locations` 创建国家
8. 使新国家成为保护者的归并国附庸（使用 `make_subject_of` 和 `subject_type:secessionists`）
9. 让保护者向原持有者宣战（使用 `cb_conquer_province` 或适当的 CB）
10. **摧毁原始叛军**以防止 `start_civil_war` 触发

**为什么这有效：** 通过在叛军达到 100% 之前（或立即达到时）摧毁它，我们阻止 `start_civil_war` 触发，完全避免当前机制。

### 实施流程

```
1. 通过月度事件检测归并国叛军达到 99-100% 进度
2. 验证叛军仍然存在且条件仍然满足
3. 识别反叛文化
4. 使用优先级系统找到保护者（原持有者 > 邻近国家 > 文化主导国家）
5. 如果未找到保护者 → 跳过（成为常规民族主义战争）
6. 识别叛军控制的所有具有反叛文化的位置
7. 为这些位置添加新国家标签的核心
8. 从核心创建国家：`create_country_from_cores_in_our_locations`
9. 使新国家成为保护者的归并国附庸
10. 让保护者向原持有者宣战
11. 摧毁原始叛军
```

### 优势

- **主动预防，而非被动应对：** 在 `start_civil_war` 触发之前拦截，完全防止当前机制
- **正确的战争领导层：** 攻击方和防御方领导层从一开始就正确设置
- **允许召唤盟友：** 双方都可以召唤盟友（对称战争）
- **尊重原持有权：** 优先级系统给原持有者优先机会
- **防止漏洞：** 无强制参与，无违反停战协议惩罚，无联合统治破裂
- **符合预期设计：** 新国家按预期成为归并国附庸

### 局限性和复杂性评估

**摘要：** 此方法具有**显著复杂性**，可能使其对模组制作不切实际。

**关键局限性：**
- **需要保护者：** 仅在存在保护者时有效（但这没问题 - 如果不存在，就是常规战争）
- **时机不确定性：** 未知执行顺序 - 月度事件是否在 `start_civil_war` 之前触发？需要广泛测试
- **玩家干预竞争条件：** 玩家可以在检查和执行之间提高稳定度或使用内阁镇压，需要验证步骤和潜在的清理机制
- **多个边缘情况：** 负月度进度（压制）、非常小的月度进度、叛军被其他方式摧毁、多个叛军、嵌套属国

**复杂性因素：**
1. **时机不确定性（高风险）：** 未知执行顺序需要测试；如果时机错误，当前机制无论如何都会触发
2. **玩家干预边缘情况（高复杂性）：** 检查和执行之间的竞争条件难以可靠处理
3. **多个验证点：** 必须验证叛军存在、进度高、月度增长为正，并处理验证失败
4. **实施复杂性：** 需要仔细处理位置识别、核心创建、国家创建、附庸设置、宣战和叛军摧毁

**建议：**

- **对于模组制作者：** 此方法可能**过于复杂**，无法可靠模组化。时机不确定性、玩家干预边缘情况和多个验证点的组合创造了高错误风险和边缘情况失败。

- **更简单的替代方案：** 考虑坚持**标准被动方法**（损害缓解），它：
  - 更可预测（事后响应，无时机问题）
  - 更少边缘情况（无玩家干预竞争条件）
  - 更可靠（经过验证的模组模式）
  - 更简单（更少移动部件）

- **对于引擎修复：** 此方法展示了**理想解决方案**的样子，但复杂性表明它更适合引擎修复，其中：
  - 时机得到保证（引擎控制执行顺序）
  - 无竞争条件（引擎原子性地处理所有检查）
  - 无需验证（引擎知道状态有效）
  - 边缘情况通过设计处理（引擎逻辑全面）

**结论：** 虽然理论上可能，但此方法的复杂性使其**对模组制作存疑**。引擎修复将更可靠和全面。
